#!/bin/bash

source_dest=~/src

declare -A source_start=( ["Headphones"]="8181" ["SickBeard"]="8081" ["CouchPotato"]="5050" ["LazyLibrarian"]="8082" )
declare -A friendly_start=( ["SABnzbd"]="9090" ["PlexMediaServer"]="32400" ["Monitoring"]="none")
declare -A abbreviations=( ["H"]="Headphones" ["SB"]="SickBeard" ["LL"]="LazyLibrarian" ["SAB"]="SABnzbd" ["P"]="PlexMediaServer" ["Plex"]="PlexMediaServer" ["CP"]="CouchPotato" ["M"]="Monitoring")
declare -A upper_case=( ["HEADPHONES"]="Headphones" ["SICKBEARD"]="SickBeard" ["LAZYLIBRARIAN"]="LazyLibrarian" ["SABNZBD"]="SABnzbd" ["PLEXMEDIASERVER"]="PlexMediaServer" ["PLEX"]="PlexMediaServer" ["COUCHPOTATO"]="CouchPotato" ["MONITORING"]="Monitoring")
kill_stop=(Headphones SickBeard LazyLibrarian CouchPotato)
friendly_stop=(SABnzbd PlexMediaServer Monitoring)
valid_apps=(${!source_start[@]} ${!friendly_start[@]})
valid_actions=('start', 'stop', 'status', 'port', 'update', 'help')
action=$1
app=$2
args="${@:2}"
num_args=$#
pid=''
running=( )
not_running=( )

help () {
  echo "   usage: arr [Action] [Application Application [...]]
                          * if no apps provided, script assumes 'all'

  [[ Actions ]]
  * case sensitive

  start              :: start application(s)
  stop               :: stop application(s)
  status             :: show status of application(s)
  port               :: show port application(s) run on
  update             :: runs 'git pull' on applicable application(s)*
  help               :: brings up this handy dandy guide

  [[ Applications ]]
  * NOT case sensitive

  CouchPotato        :: Installed in /Applications folder
  Headphones         :: Source code found under $source_dest
  LazyLibrarian      :: Source code found under $source_dest
  Monitoring         :: Installed in /Applications folder
                        This is a Fluid app for monitoring all applications
  PlexMediaServer    :: Installed in /Applications folder
  SABnzbd            :: Installed in /Applications folder
  SickBeard          :: Source code found under $source_dest

  [[ Abbreviations ]]
  * NOT case sensitive

  CouchPotato        :: Abbreviation 'CP' is available
  Headphones         :: Abbreviation 'H' is available
  LazyLibrarian      :: Abbreviation 'LL' is available
  Monitoring         :: Abbreviation 'M' is available
  PlexMediaServer    :: Abbreviations 'P' or 'Plex' are available
  SABnzbd            :: Abbreviation 'SAB' is available
  SickBeard          :: Abbreviation 'SB' is available

  * Applicable applications are those that are run from source,
  which are Headphones, LazyLibrarian, and SickBeard."

  if [[ -z $action ]]; then
    echo ''
    echo "  arr: error: too few arguments."
  elif [[ !(${valid_actions[@]} =~ $action) ]]; then
    echo ''
    echo "  arr: error: invalid action"
  fi
  exit 1
}

booty () {
  get_pid () {
    pid=$(pgrep -f $app)
  }

  start () {
    get_pid
    if [[ -n $pid ]]; then
      echo $app already running.
    else
      if [[ ${!source_start[@]} =~ $app ]]; then
        cd $source_dest/$app
        python $app.py -d
      elif [[ ${!friendly_start[@]} =~ $app ]]; then
        open /Applications/$app.app
      fi
      get_pid
      if [[ -z $pid ]]; then
        echo Failed to start $app. :\(
      else
        echo $app started. PID: $pid
      fi
    fi
  }

  stop () {
    get_pid
    if [[ -z $pid ]]; then
      echo $app wasn\'t running.
    else
      if [[ ${kill_stop[@]} =~ $app ]]; then
        kill $pid
      elif [[ ${friendly_stop[@]} =~ $app ]]; then
        osascript -e 'tell application "'$app'" to quit'
      fi
      sleep 3
      get_pid
      if [[ -n $pid ]]; then
        echo Failed to stop $app. :\( PID: $pid
      else
        echo $app stopped.
      fi
    fi
  }

  status () {
    if [[ $app != invalid ]]; then
      get_pid
      if [[ -z $pid ]]; then
        not_running+=("$app is not running.")
      else
        running+=("$app is running.")
      fi
    fi
  }

  port () {
    if [[ "${!source_start[@]}" =~ $app ]]; then
      echo $app runs on port "${source_start[$app]}"
    elif [[ "${!friendly_start[@]}" =~ $app ]]; then
      echo $app runs on port "${friendly_start[$app]}"
    fi
  }

  update () {
    if [[ "${!source_start[@]}" =~ $app ]]; then
      cd $source_dest/$app
      status=$(git pull)
      echo $app: $status
    elif [[ "${!friendly_start[@]}" =~ $app ]]; then
      echo "Sorry, but you have to update via the UI"
    fi
    if [[ $status != "Already up-to-date." ]]; then
      # not entirely sure if this works...all my projects are already up to date :(
      # so i can't easily test it
      get_pid
      if [[ -n $pid ]]; then
        stop
        sleep 5
        start
      fi
    fi
  }

  if [[ $action == 'start' ]]; then
    start
  elif [[ $action == 'stop' ]]; then
    stop
  elif [[ $action == 'status' ]]; then
    status
  elif [[ $action == 'port' ]]; then
    port
  elif [[ $action == 'update' ]]; then
    update
  elif [[ $action == 'help' ]]; then
    help
  fi
}

if [[ -z $action || !(${valid_actions[@]} =~ $action) ]]; then
  help
elif [[ -z $app || $app == all ]]; then
  args=${valid_apps[@]}
fi

for i in $args
do
  if [[ ${!abbreviations[@]} =~ ${i^^} ]]; then
    app=${abbreviations[${i^^}]}
  elif [[ ${!upper_case[@]} =~ ${i^^} ]]; then
    app=${upper_case[${i^^}]}
  else
    echo ERROR: $i is not a valid app.
    app=invalid
  fi
  booty
done

# this allows me to sort
# so that running apps are displayed first
# when calling status
if [[ $action == status ]]; then
  if [[ (-z $2  || $num_args > 3) && ${#running[@]} > 0 ]]; then
    running+=("-----------------------")
  fi
  statuses=("${running[@]}" "${not_running[@]}")
  for i in "${statuses[@]}"
  do
    echo $i
  done
fi
